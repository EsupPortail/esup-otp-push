import { useState, useEffect, useRef } from 'react';
import messaging from '@react-native-firebase/messaging';
import { storage } from '../utils/storage';
import { notification, refresh, otpServerStatus } from '../services/auth';
import { NavigationContainer, useNavigation } from '@react-navigation/native';

const useNotifications = () => {
  const [notified, setNotified] = useState(false);
  const [additionalData, setAdditionalData] = useState(null);
  const [otpServersObjects, setOtpServersObjects] = useState(
    storage.getString('otpServers') ? JSON.parse(storage.getString('otpServers')) : {}
  );
  const otpServersStackRef = useRef([]);
  const isProcessingRef = useRef(false);
  const lastProcessedLtRef = useRef(null); // Pour Ã©viter de retraiter la mÃªme notification

  useEffect(() => {
    console.log('ðŸ“± useEffect exÃ©cutÃ© avec otpServersObjects:', JSON.stringify(otpServersObjects), 'notified:', notified);

    if (isProcessingRef.current) {
      console.log('ðŸ“± useEffect ignorÃ©: dÃ©jÃ  en cours de traitement');
      return;
    }
    isProcessingRef.current = true;

    const initializeToken = async () => {
      try {
        let currentGcmId = storage.getString('gcm_id') || '';
        currentGcmId = currentGcmId.replace(/^"|"$/g, '');
        const newToken = await Promise.race([
          messaging().getToken(),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout getToken')), 10000)),
        ]);
        console.log('ðŸ“± Nouveau token Firebase:', newToken);

        if (!currentGcmId) {
          storage.set('gcm_id', newToken);
          console.log('ðŸ“± gcm_id initialisÃ©:', newToken);
        } else if (currentGcmId !== newToken) {
          console.log('ðŸ“± Mise Ã  jour du gcm_id:', currentGcmId, '->', newToken);
          const servers = Object.entries(otpServersObjects);
          for (const [otpServerKey, serverData] of servers) {
            try {
              const result = await refresh(
                serverData.host,
                serverData.uid,
                serverData.tokenSecret,
                currentGcmId,
                newToken
              );
              console.log(`ðŸ“± Refresh pour ${otpServerKey}:`, result);
            } catch (error) {
              console.warn(`ðŸ“± Ã‰chec du refresh pour ${otpServerKey}:`, error.message);
            }
          }
          storage.set('gcm_id', newToken);
          console.log('ðŸ“± gcm_id mis Ã  jour:', newToken);
        } else {
          console.log('ðŸ“± gcm_id inchangÃ©:', currentGcmId);
        }
      } catch (error) {
        console.error('Erreur lors de lâ€™initialisation du token:', error.message);
      }
    };

    const checkInitialNotification = async () => {
      try {
        const remoteMessage = await messaging().getInitialNotification();
        if (remoteMessage && remoteMessage.data && remoteMessage.data.action === 'auth') {
          console.log('ðŸ“± Notification initiale dÃ©tectÃ©e:', remoteMessage.data);
          if (remoteMessage.data.lt !== lastProcessedLtRef.current) {
            notification(
              remoteMessage.data,
              otpServersObjects,
              setOtpServersObjects,
              setNotified,
              setAdditionalData
            );
            lastProcessedLtRef.current = remoteMessage.data.lt;
          } else {
            console.log('ðŸ“± Notification initiale dÃ©jÃ  traitÃ©e:', remoteMessage.data.lt);
          }
        } else {
          console.log('ðŸ“± Aucune notification initiale dÃ©tectÃ©e');
        }
      } catch (error) {
        console.error('Erreur dans checkInitialNotification:', error.message);
      }
    };

    const initAuth = async () => {
      if (Object.keys(otpServersObjects).length === 0) {
        console.warn('ðŸ“± initAuth: Aucun serveur OTP configurÃ©');
        return;
      }

      if (notified) {
        console.log('ðŸ“± initAuth: Notification dÃ©jÃ  trouvÃ©e, arrÃªt');
        return;
      }

      otpServersStackRef.current = [...Object.keys(otpServersObjects)];
      console.log('ðŸ“± initAuth: otpServersStack initialisÃ©:', otpServersStackRef.current);

      while (otpServersStackRef.current.length > 0) {
        const otpServer = otpServersStackRef.current.pop();
        console.log('ðŸ“± initAuth: VÃ©rification de', otpServer);
        try {
          await otpServerStatus(
            otpServer,
            otpServersObjects,
            setOtpServersObjects,
            setNotified,
            setAdditionalData,
            otpServersStackRef.current,
            lastProcessedLtRef
          );
          if (notified) {
            console.log('ðŸ“± initAuth: Notification trouvÃ©e, arrÃªt');
            break;
          }
        } catch (error) {
          console.error('ðŸ“± Erreur dans initAuth pour', otpServer, ':', error.message);
        }
      }
    };

    const setup = async () => {
      await initializeToken();
      await checkInitialNotification();
      await initAuth();
      isProcessingRef.current = false;
    };
    setup();

    const unsubscribeForeground = messaging().onMessage(async (remoteMessage) => {
      console.log('ðŸ“± Notification foreground data:', remoteMessage.data);
      console.log('ðŸ“± Notification foreground response:', remoteMessage);
      if (
        remoteMessage.data &&
        (remoteMessage.data.action === 'auth' || remoteMessage.data.action === 'desync') &&
        remoteMessage.data.url &&
        remoteMessage.data.uid
      ) {
        if (remoteMessage.data.lt !== lastProcessedLtRef.current) {
          notification(
            remoteMessage.data,
            otpServersObjects,
            setOtpServersObjects,
            setNotified,
            setAdditionalData
          );
          lastProcessedLtRef.current = remoteMessage.data.lt;
        } else {
          console.log('ðŸ“± Notification foreground dÃ©jÃ  traitÃ©e:', remoteMessage.data.lt);
        }
      } else {
        console.warn('ðŸ“± Notification foreground ignorÃ©e: donnÃ©es invalides', remoteMessage.data);
      }
    });

    const unsubscribeOpened = messaging().onNotificationOpenedApp((remoteMessage) => {
      console.log('ðŸ“± Notification pending ouverte (background):', remoteMessage);
      if (
        remoteMessage &&
        remoteMessage.data &&
        (remoteMessage.data.action === 'auth' || remoteMessage.data.action === 'desync') &&
        remoteMessage.data.url &&
        remoteMessage.data.uid
      ) {
        if (remoteMessage.data.lt !== lastProcessedLtRef.current) {
          notification(
            remoteMessage.data,
            otpServersObjects,
            setOtpServersObjects,
            setNotified,
            setAdditionalData
          );
          lastProcessedLtRef.current = remoteMessage.data.lt;
        } else {
          console.log('ðŸ“± Notification ouverte dÃ©jÃ  traitÃ©e:', remoteMessage.data.lt);
        }
      } else {
        console.warn('ðŸ“± Notification ouverte ignorÃ©e: donnÃ©es invalides', remoteMessage?.data);
      }
    });

    const unsubscribeTokenRefresh = messaging().onTokenRefresh(async (newToken) => {
      try {
        let currentGcmId = storage.getString('gcm_id') || '';
        currentGcmId = currentGcmId.replace(/^"|"$/g, '');
        console.log('ðŸ“± Token refresh:', newToken);

        if (currentGcmId !== newToken) {
          const servers = Object.entries(otpServersObjects);
          for (const [otpServerKey, serverData] of servers) {
            try {
              const result = await refresh(
                serverData.host,
                serverData.uid,
                serverData.tokenSecret,
                currentGcmId,
                newToken
              );
              console.log(`ðŸ“± Refresh pour ${otpServerKey}:`, result);
            } catch (error) {
              console.warn(`ðŸ“± Ã‰chec du refresh pour ${otpServerKey}:`, error.message);
            }
          }
          storage.set('gcm_id', newToken);
          console.log('ðŸ“± gcm_id mis Ã  jour via refresh:', newToken);
        }
      } catch (error) {
        console.error('Erreur lors du refresh du token:', error.message);
      }
    });

    return () => {
      console.log('ðŸ“± Nettoyage useEffect');
      unsubscribeForeground();
      unsubscribeOpened();
      unsubscribeTokenRefresh();
      isProcessingRef.current = false;
    };
  }, [otpServersObjects, notified]);

  return { notified, setNotified, additionalData, setAdditionalData, otpServersObjects, setOtpServersObjects };
};

export default useNotifications;